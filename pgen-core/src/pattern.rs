//! Creating and using patterns that describe password generation.

use num_bigint::BigUint;
use num_traits::{One, Pow};

use std::convert::TryFrom;
use std::str::FromStr;

use crate::wordlist::Wordlist;
use crate::PgenError;

/// A description of how a password should be generated.
#[derive(Debug)]
pub struct Pattern(Vec<Wordlist>);

impl Pattern {
    /// Calculate the total number of possible passwords this pattern can generate.
    pub fn combinations(&self) -> BigUint {
        self.0
            .iter()
            .fold(One::one(), |acc, elem| acc * elem.words())
    }

    /// Calculate the number of bits of entropy in a password generated by this pattern.
    ///
    /// The "bits of entropy" is just the base 2 logarithm of the number of possible combinations.
    /// It's a useful metric to use when comparing a password's strength to things like AES keys.
    /// For example, a password with 128 bits of entropy should have the same resistance to brute
    /// forcing as a 128-bit AES key.
    ///
    /// This function will approximate the number of bits of entropy to the nearest whole number,
    /// rounding down.
    ///
    /// This function will return a maximum of [`u8::MAX`]. If a password pattern will generate more
    /// than [`u8::MAX`] bits of entropy, it will still be reported as only [`u8::MAX`].
    pub fn entropy_bits(&self) -> u8 {
        // Only calculate the number of combinations once
        let combos = self.combinations();

        // We need the base to be BigUint so `pow()` returns a BigUint
        let base = BigUint::from(2_u8);

        for power in 1..u8::MAX {
            if Pow::pow(&base, power) > combos {
                return power - 1;
            }
        }

        u8::MAX
    }

    /// Generate a new password based on the pattern.
    ///
    /// This generator will iterate through each wordlist referenced by the pattern and select a
    /// random entry from each one. The random selections will then be concatenated together in
    /// order.
    ///
    /// # Examples
    ///
    /// Generating a single password using the test-only wordlists.
    ///
    /// ```
    /// use std::str::FromStr;
    /// use pgen_core::pattern::Pattern;
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut pat = Pattern::from_str("tTT")?;
    /// let password: String = pat.generate();
    /// assert_eq!(&password, "password11");
    /// # Ok(())
    /// # }
    /// ```
    pub fn generate(&mut self) -> String {
        let mut password = String::default();

        for list in &mut self.0 {
            password.push_str(list.pick());
        }

        password
    }
}

impl FromStr for Pattern {
    type Err = PgenError;

    /// Create a new pattern using a string representation.
    ///
    /// Pattern strings are sequences of characters that define which wordlists to use, and in what
    /// order. Each character in the string refers to a specific wordlist. Wordlists can be used
    /// multiple times in a pattern string.
    ///
    /// Note that characters in pattern strings are case-sensitive. The pattern string `WWW` will
    /// use [`u8::MAX`] different wordlists thanw` will.
    ///
    /// # Examples
    ///
    /// This example creates a pattern that will generate a password containing one short word
    /// followed by a symbol and then a number.
    ///
    /// ```
    /// use std::str::FromStr;
    /// use pgen_core::pattern::Pattern;
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut pat = Pattern::from_str("wSN")?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// An error will be returned if you try to parse a string containing a character that doesn't
    /// match any known wordlists.
    ///
    /// ```
    /// # use std::str::FromStr;
    /// # use pgen_core::pattern::Pattern;
    /// let mut pat = Pattern::from_str("!?!?");
    /// assert!(pat.is_err());
    /// ```
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut lists = Vec::new();

        for chr in s.chars() {
            lists.push(Wordlist::try_from(chr)?);
        }

        Ok(Pattern(lists))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use num_bigint::BigUint;

    fn combos_100() -> Pattern {
        Pattern::from_str("NN").unwrap()
    }

    #[test]
    fn entropy_100_combos() {
        assert_eq!(combos_100().entropy_bits(), 6);
    }

    #[test]
    fn combinations_100() {
        assert_eq!(combos_100().combinations(), BigUint::from(100_u8));
    }
}
